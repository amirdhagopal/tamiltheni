import { Utils } from './utils';
import { Timer } from './timer';
import { AudioManager } from './audio_manager';
import { Layout } from './layout';
import { config } from './config';
import theniWords from '../data/theni_words.json';
import { Word } from '../types';

// Constants
// const TOTAL_SLIDES = 800;

// State Variables
let currentSlide = 0;

// Audio state
let audioEnabled = true; // Default to on
const audioTimeout: ReturnType<typeof setTimeout> | null = null;
// synth removed - using AudioManager

// Filter and sequence state
let currentFilter = 'all'; // Difficulty
let selectedCategories: string[] = []; // List of selected Category strings "En - Ta"
let availableCategories: string[] = []; // All unique categories found in slides
let allSlides: HTMLDivElement[] = [];
let filteredSlides: HTMLDivElement[] = [];
// let originalOrder = []; // Not used?
let isShuffled = false;
let viewedPartners: Record<number, number> = {}; // Stores index -> partnerIndex mapping for persistence
const sentenceCache: Record<string, { tamil: string; english: string }> = {}; // Stores "word1|word2" -> {tamil, english}
const imageCache: Record<string, string> = {}; // Cache for images to avoid re-fetching

// Timer state handled by Timer module

async function initApp() {
    // Load Data - we use imported theniWords
    // If not loaded, we have issues, but import ensures it is loaded.

    // Initialize slide arrays by generating them if not present?
    // In theni2.html, slides are often generated by JS. Theni1 used generateSlides().
    // The previous code for Theni2 seemed to assume slides might exist or loaded data.
    // Let's implement generateSlides similar to Theni1 but with the specific layout for Theni2 cards.
    // The original code had `loadSlidesData` which created DOM elements.
    generateSlides();

    // Populate categories from the slides
    populateCategories();

    // Update progress on load
    updateProgress();

    // Initialize timer
    Timer.init(config.timerDurations.theni2);

    if (window.location.hash) {
        handleHashChange();
    } else {
        updateUI();
    }

    // Attach AI Button Listener
    document.getElementById('aiBtn')?.addEventListener('click', generateSentence);
}

function generateSlides() {
    // Generate virtual slides for logic compatibility
    // Theni 2 does NOT put all slides in DOM. It uses a single Dual View container.
    // So we just need to populate the arrays.

    // Initialize arrays with virtual elements (or just data objects wrapper)
    // For compatibility with existing filtering logic which expects "slide" elements with classes:
    // We will create them in memory but NOT append them to DOM.

    allSlides = (theniWords as Word[]).map((item: Word, index: number) => {
        const el = document.createElement('div');
        el.className = 'slide'; // virtual
        el.id = `slide - ${index} `;

        // Add badges for filtering logic to work (start with string)
        el.innerHTML = `
            <div class="category-badge">${item.category}</div>
            <div class="category-badge-ta">${item.category_ta}</div>
            <div class="difficulty-badge">${item.difficulty}</div>
            <div class="word-en">${item.word_en}</div>
            <div class="word-ta">${item.word_ta}</div>
        `;
        return el;
    });

    filteredSlides = [...allSlides];
}

function getSafeFilename(word: string) {
    if (!word) return '';
    return word
        .replace(/[^a-zA-Z0-9 \-_]/g, '')
        .trim()
        .replace(/\s+/g, '_')
        .toLowerCase();
}

// --- Logic Functions ---

export function toggleControlPanel() {
    const panel = document.getElementById('controlPanel');
    if (panel) {
        panel.classList.toggle('collapsed');
        document.getElementById('categoryMenu')?.classList.remove('show');
    }
}

function toggleDropdown(event: Event) {
    event.stopPropagation();
    document.getElementById('categoryMenu')?.classList.toggle('show');
}

function populateCategories() {
    const catMap = new Map();
    allSlides.forEach((slide) => {
        const en = slide.querySelector('.category-badge')?.textContent;
        const ta = slide.querySelector('.category-badge-ta')?.textContent;
        const key = `${en} - ${ta}`;
        if (!catMap.has(key)) {
            catMap.set(key, true);
        }
    });

    availableCategories = Array.from(catMap.keys());
    selectedCategories = [...availableCategories]; // Select all by default

    const list = document.getElementById('categoryList');
    if (list) {
        list.innerHTML = '';
        availableCategories.forEach((cat) => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = true;
            checkbox.id = `cat-${cat}`;

            const label = document.createElement('span');
            label.innerText = cat;

            item.appendChild(checkbox);
            item.appendChild(label);

            item.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCategory(cat);
            });
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCategory(cat);
            }); // prevent bubbling twice if needed

            // Keyboard support for dropdown item
            item.setAttribute('tabindex', '0');
            item.setAttribute('role', 'checkbox');
            item.setAttribute('aria-checked', 'true');
            item.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleCategory(cat);
                }
            });

            list.appendChild(item);
        });
    }
    updateCategoryText();
}

function toggleCategory(category: string) {
    const index = selectedCategories.indexOf(category);
    if (index > -1) {
        selectedCategories.splice(index, 1);
    } else {
        selectedCategories.push(category);
    }

    // Update UI
    const checkbox = document.getElementById(`cat-${category}`) as HTMLInputElement;
    if (checkbox) checkbox.checked = selectedCategories.includes(category);

    updateCategoryText();
    applyFilters();
}

function toggleAllCategories(event: Event) {
    const checkbox = document.getElementById('selectAllCats') as HTMLInputElement;

    // If the div was clicked (not the checkbox itself), toggle the checkbox manually
    if (event.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
    }

    const targetState = checkbox.checked;

    if (targetState) {
        selectedCategories = [...availableCategories];
    } else {
        selectedCategories = [];
    }

    // Update UI for all individual category checkboxes
    document.querySelectorAll('#categoryList input').forEach((cb: Element) => {
        (cb as HTMLInputElement).checked = targetState;
    });

    updateCategoryText();
    applyFilters();
}

function updateCategoryText() {
    const text = document.getElementById('selectedCatText');
    const checkbox = document.getElementById('selectAllCats') as HTMLInputElement;
    if (!text || !checkbox) return;

    if (selectedCategories.length === availableCategories.length) {
        text.textContent = 'All Categories';
        checkbox.checked = true;
    } else if (selectedCategories.length === 0) {
        text.textContent = 'None selected';
        checkbox.checked = false;
    } else {
        text.textContent = `${selectedCategories.length} selected`;
        checkbox.checked = false;
    }
}

function applyFilters(resetToStart = true) {
    filteredSlides = allSlides.filter((slide) => {
        const diffBadge = slide.querySelector('.difficulty-badge')?.textContent;
        const catBadge = slide.querySelector('.category-badge')?.textContent;
        const catBadgeTa = slide.querySelector('.category-badge-ta')?.textContent;
        const catKey = `${catBadge} - ${catBadgeTa}`;

        const difficultyMatch = currentFilter === 'all' || diffBadge === currentFilter;
        const categoryMatch = selectedCategories.includes(catKey);

        return difficultyMatch && categoryMatch;
    });

    if (isShuffled) {
        // Fisher-Yates shuffle
        Utils.shuffleArray(filteredSlides);
    }

    // Reset partner history when filters change
    viewedPartners = {};

    if (resetToStart) currentSlide = 0;
    updateProgress();
    updateUI();
}

function filterDifficulty(difficulty: string) {
    currentFilter = difficulty;

    // Update button states
    document.querySelectorAll('.pill-button').forEach((btn) => {
        btn.classList.remove('active');
        btn.setAttribute('aria-pressed', 'false');
    });
    const btn = document.getElementById(`filter${difficulty === 'all' ? 'All' : difficulty}`);
    if (btn) {
        btn.classList.add('active');
        btn.setAttribute('aria-pressed', 'true');
    }

    applyFilters();
}

function shuffleSlides() {
    isShuffled = true;
    const btn = document.getElementById('btn-shuffle');
    if (btn) {
        btn.classList.add('active');
        btn.setAttribute('aria-pressed', 'true');
    }
    applyFilters();
}

function resetSequence() {
    isShuffled = false;
    const btn = document.getElementById('btn-shuffle');
    if (btn) {
        btn.classList.remove('active');
        btn.setAttribute('aria-pressed', 'false');
    }
    applyFilters();
}

function updateProgress() {
    const currentFilteredD1 = filteredSlides.filter(
        (s) => s.querySelector('.difficulty-badge')?.textContent === 'D1'
    ).length;
    const currentFilteredD2 = filteredSlides.filter(
        (s) => s.querySelector('.difficulty-badge')?.textContent === 'D2'
    ).length;

    const filterText = currentFilter === 'all' ? 'All Difficulty' : currentFilter;
    const shuffleText = isShuffled ? ' (Shuffled)' : '';

    const progressInfo = document.getElementById('progressInfo');
    if (progressInfo) {
        progressInfo.textContent = `${filteredSlides.length === 0 ? 0 : currentSlide + 1}/${filteredSlides.length} slides - Filter: ${filterText}${shuffleText} (Matches: D1=${currentFilteredD1}, D2=${currentFilteredD2})`;
    }
}

// ===== AI Functions =====
function saveApiKey(key: string) {
    localStorage.setItem('gemini_api_key', key);
    const status = document.getElementById('keyStatus');
    if (status) {
        status.style.display = 'inline';
        setTimeout(() => (status.style.display = 'none'), 3000);
    }
}

// Load saved API key from localStorage
function loadSavedApiKey() {
    const savedKey = localStorage.getItem('gemini_api_key');
    if (savedKey) {
        const input = document.getElementById('apiKeyInput') as HTMLInputElement;
        if (input) input.value = savedKey;
    }
}

async function generateSentence() {
    const aiBtn = document.getElementById('aiBtn') as HTMLButtonElement | null;
    const resultDiv = document.getElementById('aiResult');
    const resultText = document.getElementById('aiText');
    const resultTextEn = document.getElementById('aiTextEn');

    // PAUSE TIMER during interaction
    Timer.pause();

    // Get current words
    const word1 = document.getElementById('card1Ta')?.textContent;
    const word2 = document.getElementById('card2Ta')?.textContent;

    if (!word1 || !word2) {
        alert('Cannot generate sentence without two words.');
        return;
    }

    const apiKey = localStorage.getItem('gemini_api_key');

    if (!apiKey) {
        alert('Please enter your Gemini API Key in the settings first.');
        // Open settings panel
        const panel = document.getElementById('controlPanel');
        if (panel && panel.classList.contains('collapsed')) {
            panel.classList.remove('collapsed');
        }
        return;
    }

    // Use the available key
    const validKey = apiKey;

    if (!resultDiv || !resultText || !resultTextEn) return;

    const cacheKey = `${word1}|${word2}`;

    // Check Cache
    if (sentenceCache[cacheKey]) {
        const json = sentenceCache[cacheKey];
        renderResult(json);
        return;
    }

    // Loading State
    if (aiBtn) {
        aiBtn.disabled = true;
        aiBtn.innerHTML = `<span>‚è≥</span> Generating...`;
    }

    // Clear previous
    resultDiv.style.display = 'none';
    resultDiv.classList.remove('show');
    resultText!.textContent = '';
    resultTextEn!.textContent = '';

    const prompt = `Generate a simple Tamil sentence using these two words: "${word1}" and "${word2}".
    Provide the response in JSON format: { "tamil": "tamil sentence", "english": "english meaning" }
    IMPORTANT: Use the exact Tamil words provided. Keep it simple.`;

    try {
        const response = await fetch(
            `${config.gemini.baseUrl}/${config.gemini.defaultModel}:generateContent?key=${validKey}`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                }),
            }
        );

        const data = await response.json();

        if (data.error) {
            throw new Error(data.error.message || 'API Error');
        }

        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (text) {
            // cleanup markdown code blocks if present
            const cleanText = text.replace(/```json\n?|\n?```/g, '').trim();
            const json = JSON.parse(cleanText);

            // Cache it
            sentenceCache[cacheKey] = json;

            renderResult(json);
        } else {
            throw new Error('No response text');
        }
    } catch (e: unknown) {
        const errorMessage = e instanceof Error ? e.message : 'Unknown error';
        console.error('AI Error:', e);
        alert('Error generating sentence: ' + errorMessage);
        // Restore UI state
        if (resultDiv) resultDiv.style.display = 'none';
    } finally {
        if (aiBtn) {
            aiBtn.disabled = false;
            aiBtn.innerHTML = `<span>‚ú®</span> Generate Sentence`;
        }
    }

    function renderResult(json: { tamil: string; english: string }) {
        resultText!.textContent = json.tamil;
        resultTextEn!.textContent = json.english;
        resultDiv!.style.display = 'flex';
        // Small delay for transition
        setTimeout(() => resultDiv!.classList.add('show'), 10);

        // Speak the Tamil sentence
        if (audioEnabled) {
            AudioManager.speak(json.tamil, 'ta-IN');
        }
    }
}

function toggleAudio() {
    const audioCheckbox = document.getElementById('audioToggle') as HTMLInputElement;
    audioEnabled = audioCheckbox.checked;

    if (audioEnabled) {
        // Speak both words in dual-card mode
        const slide1 = filteredSlides[currentSlide];
        const partnerIdx = viewedPartners[currentSlide];
        const slide2 = partnerIdx !== undefined ? filteredSlides[partnerIdx] : null;

        if (slide1) {
            const word1 = slide1.querySelector('.word-en')?.textContent;
            const word2 = slide2?.querySelector('.word-en')?.textContent;

            if (word1) {
                AudioManager.speak(word1, 'en-US');
                if (word2) {
                    setTimeout(() => {
                        if (audioEnabled) AudioManager.speak(word2, 'en-US');
                    }, 1500);
                }
            }
        }
    } else {
        if (audioTimeout) clearTimeout(audioTimeout);
        if (AudioManager.synth && AudioManager.synth.speaking) AudioManager.synth.cancel();
    }
}

function updateUI() {
    const aiResult = document.getElementById('aiResult');
    const aiText = document.getElementById('aiText');
    const aiTextEn = document.getElementById('aiTextEn');
    const aiBtn = document.getElementById('aiBtn') as HTMLButtonElement;
    if (aiResult) {
        aiResult.style.display = 'none';
        aiResult.classList.remove('show'); // Clear 'show' class
    }
    if (aiText) aiText.textContent = '';
    if (aiTextEn) aiTextEn.textContent = '';
    if (aiBtn) {
        aiBtn.disabled = false;
        aiBtn.innerHTML = '<span>‚ú®</span> Generate Sentence with AI';
    }

    // Dual view mode - show two cards
    // Reset revealed state for both cards
    document.getElementById('card1')?.classList.remove('revealed');
    document.getElementById('card2')?.classList.remove('revealed');

    if (filteredSlides.length < 2) {
        // Not enough slides for dual view
        if (document.getElementById('card1En')) document.getElementById('card1En')!.textContent = 'Not enough words';
        // Clear card 2
        updateCard(2, document.createElement('div')); // Pass empty div to clear
        return;
    }

    // Get first slide (current position)
    const slide1 = filteredSlides[currentSlide];

    // Get second slide (persistent random)
    let randomIdx: number;

    if (viewedPartners[currentSlide] !== undefined) {
        // Use stored partner if we visited this slide before in this session
        randomIdx = viewedPartners[currentSlide];
    } else {
        // Generate new partner
        do {
            randomIdx = Math.floor(Math.random() * filteredSlides.length);
        } while (randomIdx === currentSlide);
        // Store it
        viewedPartners[currentSlide] = randomIdx;
    }

    const slide2 = filteredSlides[randomIdx];

    // Preload partner image in background using getSafeFilename
    const partnerImg = slide2.querySelector('.slide-image') as HTMLImageElement;
    const partnerWord = partnerImg?.dataset.word || slide2.querySelector('.word-en')?.textContent?.toLowerCase();
    if (partnerWord) {
        const preloadImg = new Image();
        preloadImg.src = `assets/images/theni12/${getSafeFilename(partnerWord)}.jpg`;
    }

    // Update Card 1
    updateCard(1, slide1);

    // Update Card 2
    updateCard(2, slide2);

    // Pronounce both words if audio is enabled
    // Call speech directly (no setTimeout) to maintain user gesture chain for strict browsers
    if (audioEnabled) {
        const word1 = slide1.querySelector('.word-en')?.textContent;
        const word2 = slide2.querySelector('.word-en')?.textContent;
        if (word1) {
            AudioManager.speak(word1, 'en-US');
            // Queue second word - SpeechSynthesis handles queuing natively
            if (word2) {
                AudioManager.speak(word2, 'en-US');
            }
        }
    }

    // Update buttons
    (document.getElementById('firstBtn') as HTMLButtonElement).disabled = currentSlide === 0;
    (document.getElementById('prevBtn') as HTMLButtonElement).disabled = currentSlide === 0;
    (document.getElementById('nextBtn') as HTMLButtonElement).disabled = currentSlide === filteredSlides.length - 1;
    (document.getElementById('lastBtn') as HTMLButtonElement).disabled = currentSlide === filteredSlides.length - 1;

    // Update counter
    const counter = document.getElementById('counter');
    if (counter) counter.innerText = `${currentSlide + 1} / ${filteredSlides.length}`;

    // Update progress bar
    Utils.updateProgress(currentSlide, filteredSlides.length, 'progressBar', 'counter');

    // Update progress info
    updateProgress();

    // Restart timer on new slide if enabled
    const timerCheck = document.getElementById('showTimer') as HTMLInputElement;
    if (timerCheck && timerCheck.checked) {
        Timer.restart();
    }
}

function updateCard(cardNum: number, slide: HTMLDivElement) {
    try {
        const prefix = 'card' + cardNum;

        // Get data from slide
        const wordEn = slide.querySelector('.word-en')?.textContent || '';
        const wordTa = slide.querySelector('.word-ta')?.textContent || '';
        const category = slide.querySelector('.category-badge')?.textContent || '';
        const categoryTa = slide.querySelector('.category-badge-ta')?.textContent || '';
        const difficulty = slide.querySelector('.difficulty-badge')?.textContent || '';
        const img = slide.querySelector('.slide-image') as HTMLImageElement;
        const word = img?.dataset.word || wordEn.toLowerCase();

        // Update card elements
        if (document.getElementById(prefix + 'En')) document.getElementById(prefix + 'En')!.textContent = wordEn;
        if (document.getElementById(prefix + 'Ta')) document.getElementById(prefix + 'Ta')!.textContent = wordTa;
        if (document.getElementById(prefix + 'Cat')) document.getElementById(prefix + 'Cat')!.textContent = category;
        if (document.getElementById(prefix + 'CatTa'))
            document.getElementById(prefix + 'CatTa')!.textContent = categoryTa;
        if (document.getElementById(prefix + 'Diff'))
            document.getElementById(prefix + 'Diff')!.textContent = difficulty;

        // Load image
        const cardImg = document.getElementById(prefix + 'Img') as HTMLImageElement;
        if (cardImg) {
            const safeFilename = getSafeFilename(word);
            // Check cache first
            if (imageCache[word]) {
                cardImg.src = imageCache[word];
            } else {
                const localPath = `assets/images/theni12/${safeFilename}.jpg`;
                const finalPath = (import.meta.env?.BASE_URL || '') + localPath;

                cardImg.src = finalPath;

                cardImg.onerror = function () {
                    cardImg.onerror = null;
                    // Try fallback to relative path if absolute failed
                    if (cardImg.src.includes(finalPath)) {
                        console.warn(`[ImageLoad] Failed absolute path: ${finalPath}. Retrying with relative...`);
                        cardImg.src = `../${localPath}`; // relative to html/ folder
                        return;
                    }
                    cardImg.src = `https://placehold.co/300x180?text=${encodeURIComponent(wordEn)}`;
                };
            }
            cardImg.alt = wordEn;
        }
    } catch (err) {
        console.error('Error in updateCard ' + cardNum + ':', err);
    }
}

function goToFirst() {
    if (filteredSlides.length > 0) {
        currentSlide = 0;
        updateUI();
    }
}

function goToLast() {
    if (filteredSlides.length > 0) {
        currentSlide = filteredSlides.length - 1;
        updateUI();
    }
}

function changeSlide(direction: number) {
    const newIndex = currentSlide + direction;
    if (newIndex >= 0 && newIndex < filteredSlides.length) {
        currentSlide = newIndex;
        updateUI();
    }
}

function handleNextAction() {
    if (!filteredSlides[currentSlide]) return;

    // Check if both cards are revealed
    const card1 = document.getElementById('card1');
    const card2 = document.getElementById('card2');
    if (!card1 || !card2) return;

    const bothRevealed = card1.classList.contains('revealed') && card2.classList.contains('revealed');

    if (bothRevealed) {
        // Already revealed, move to next slide
        changeSlide(1);
    } else {
        // Not revealed yet, reveal both cards
        card1.classList.add('revealed');
        card2.classList.add('revealed');
    }
}

function handleHashChange() {
    const hash = window.location.hash.substring(1);
    const targetSlideId = `slide-${parseInt(hash) - 1}`;

    const index = filteredSlides.findIndex((s) => s.id === targetSlideId);
    if (index !== -1) {
        currentSlide = index;
        updateUI();
    } else if (filteredSlides.length > 0) {
        // If current hash slide isn't in filtered view, ensure we are at a valid index
        if (currentSlide >= filteredSlides.length) currentSlide = 0;
        updateUI();
    }
}

// Initialization and Event Listeners
export function init() {
    // 1. Layout Init
    Layout.init({
        title: '‡Æ™‡Æø‡ÆØ‡Øã‡Æ∞‡Æø‡ÆØ‡Ææ ‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç‡Æ™‡Øç ‡Æ™‡Æ≥‡Øç‡Æ≥‡Æø - ‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç‡Æ§‡Øç ‡Æ§‡Øá‡Æ©‡Æø 2026 - Theni 2',
        contentHTML: `
            <div class="control-row">
                <span class="control-label">Categories:</span>
                <div class="category-dropdown">
                    <button class="dropdown-button" id="cat-dropdown-btn">
                        <span id="selectedCatText">All Categories</span>
                        <span>‚ñº</span>
                    </button>
                    <div class="dropdown-menu" id="categoryMenu">
                        <div class="dropdown-item header" id="select-all-cat-row">
                            <input type="checkbox" id="selectAllCats" checked>
                            <span>Select All / None</span>
                        </div>
                        <div id="categoryList"></div>
                    </div>
                </div>
            </div>
            <div class="control-row">
                <span class="control-label">Difficulty:</span>
                <div class="pill-group">
                    <button class="pill-button active" id="filterAll" aria-pressed="true">All</button>
                    <button class="pill-button" id="filterD1" aria-pressed="false">D1 Only</button>
                    <button class="pill-button" id="filterD2" aria-pressed="false">D2 Only</button>
                </div>
            </div>
            <div class="control-row">
                <span class="control-label">Sequence:</span>
                <div class="pill-group">
                    <button class="action-button" id="btn-shuffle" aria-pressed="false"><span aria-hidden="true">üîÄ</span> Shuffle</button>
                    <button class="action-button" id="btn-reset-seq"><span aria-hidden="true">‚Ü©Ô∏è</span> Reset</button>
                </div>
                <div style="margin-left: auto; display: flex; gap: 15px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.85em;">
                        <input type="checkbox" id="showTimer" checked> ‚è±Ô∏è Timer (20s)
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.85em;">
                        <input type="checkbox" id="audioToggle"> üîä Audio
                    </label>
                </div>
            </div>
            <div class="control-row">
                <span class="control-label">Progress:</span>
                <span class="progress-info" id="progressInfo">Loading...</span>
                <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                    <label style="font-size: 0.85em; display: flex; align-items: center; gap: 6px;">üîë Gemini AI API:</label>
                    <input type="password" id="apiKeyInput" placeholder="Enter API Key" 
                           style="padding: 4px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.15); color: white; font-size: 0.85em; width: 140px;">
                    <style>#apiKeyInput::placeholder { color: rgba(255,255,255,0.7); font-style: italic; }</style>
                </div>
            </div>
        `,
        timerDisplay: '00:20',
        injectNavigation: true,
    });

    // 2. Attach Listeners
    document.getElementById('cat-dropdown-btn')?.addEventListener('click', toggleDropdown);
    document.getElementById('select-all-cat-row')?.addEventListener('click', toggleAllCategories);

    document.getElementById('filterAll')?.addEventListener('click', () => filterDifficulty('all'));
    document.getElementById('filterD1')?.addEventListener('click', () => filterDifficulty('D1'));
    document.getElementById('filterD2')?.addEventListener('click', () => filterDifficulty('D2'));

    document.getElementById('btn-shuffle')?.addEventListener('click', shuffleSlides);
    document.getElementById('btn-reset-seq')?.addEventListener('click', resetSequence);

    document.getElementById('showTimer')?.addEventListener('change', Timer.toggleVisibility.bind(Timer));
    document.getElementById('audioToggle')?.addEventListener('change', toggleAudio);

    document.getElementById('firstBtn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        goToFirst();
    });
    document.getElementById('prevBtn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        changeSlide(-1);
    });
    document.getElementById('nextBtn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        handleNextAction();
    });
    document.getElementById('lastBtn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        goToLast();
    });

    document
        .getElementById('apiKeyInput')
        ?.addEventListener('change', (e) => saveApiKey((e.target as HTMLInputElement).value));
    document.getElementById('aiBtn')?.addEventListener('click', generateSentence);

    // Global Click Listener for Dropdowns
    document.addEventListener('click', (e) => {
        if (!(e.target as Element).closest('.category-dropdown')) {
            document.getElementById('categoryMenu')?.classList.remove('show');
        }
        if (!(e.target as Element).closest('.control-panel')) {
            const panel = document.getElementById('controlPanel');
            if (panel && !panel.classList.contains('collapsed')) {
                panel.classList.add('collapsed');
            }
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') changeSlide(-1);
        if (e.key === 'ArrowRight' || e.key === ' ' || e.key === 'Enter') {
            handleNextAction();
        }
        if (e.key === 'Home') goToFirst();
        if (e.key === 'End') goToLast();
        if (e.key === '1') filterDifficulty('D1');
        if (e.key === '2') filterDifficulty('D2');
        if (e.key === 'a' || e.key === 'A') filterDifficulty('all');
        if (e.key === 's' || e.key === 'S') shuffleSlides();
        if (e.key === 'r' || e.key === 'R') resetSequence();
    });

    window.addEventListener('hashchange', handleHashChange);

    // Init App Logic
    loadSavedApiKey();
    initApp();
}

// Initialization and Event Listeners
document.addEventListener('DOMContentLoaded', init);
